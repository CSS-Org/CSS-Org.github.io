{"title":"CS Tech","description":"BartGod","language":"ko","link":"https://CSS-Org.github.io","pubDate":"Mon, 28 Nov 2016 15:00:00 GMT","lastBuildDate":"Tue, 29 Nov 2016 08:24:03 GMT","generator":"hexo-generator-json-feed","webMaster":"CS Tech Team","items":[{"title":"ie에서 localstorage 사용할 때 유의점","link":"https://CSS-Org.github.io/2016/11/29/when-using-localstorage-within-the-ie/","description":"갑자기 왜로컬 스토리지를 사용해서, 페이지의 Form 값을 임시로 저장하는 기능을 개발했다. Chrome에서 만들어 테스트하고 배포를 하려던 참에, 혹시나해서 IE(10,Edge 모드)에서 테스트하려고 보니까 왠일인지 동작하지 않았다. 두 창에서 Local Storage key값의 동기화 문제Form은 팝업이였고, Form 값이 변경되면 로컬스토리지에 저장된 후 다른 창에 떠있는 개인 페이지에서 임시저장된 Form 팝업을 링크하거나 삭제하는 식의 기능이였다. 문제는 서로 다른 두 창에 대해서, 로컬스토리지의 key값이 동기화 되지 않는데서 시작했다. 첫 번째 창에서 Storage에 저장하면, 두번째 창에서는 Storage를 읽고 변경된 사항에 대해서 표현되어야 했으나 도무지 갱신된 key값을 다른 창에서 찾을 수가 없었다. 예를 들어서, 두 창을 열어둔 후에, 첫번째 창에서 다음과 같이 localStorage에 Item을 추가해보자. 123var ls = window.localStorage;ls.setItem('party', 'yeah!'); 헌데 두번째 창에서 localStorage에 저장된 key값을 확인해보면, 첫번째 창과 key값이 동일하지 않다. 123var ls2 = window.localStorage;Object.keys(ls2); 어떻게 해야할까사용자 PC마다 localStorage를 얼마나 사용하고 있는지 알 수 없었기에, 키값으로 미리 데이터를 필터링해서 사용하지 않으면 어떤 성능 상 이슈가 발생할 지 알 수 없는 상황이였다. localStorage를 이것 저것 사용해보다가 한가지 대안이라고 하기에도 민망한 방법을 발견했는데 창이 다르더라도 getItem(key)를 통해서 바로 호출하면, 데이터를 가져올 수 있었다 ls2 내부를 아무리 찾아봐도 없던 ‘party’ 데이터가 key값으로 바로 호출하면 보인다. 1ls2.getItem('party'); 이렇게해서, IE인 경우에, 서로 다른 창에서 localStorage를 사용할 경우, 동기화된 Key값을 얻기 위해 123456789101112if(browserDetector.detectWindow(window).browser === 'ie') &#123; keys = function () &#123; let idx = 0; let result = []; while (l.key(idx)) &#123; result.push(l.key(idx)); idx++; &#125; return result; &#125;; return keys();&#125; localStorage에 존재하지 않는 index를 요청할 때, null을 리턴하는 것을 이용해서 다음과 같이 key값을 빼서 사용하게 되었다. 결론개발 환경과 사용자 환경에 대한 테스트의 중요성을 다시 한번 느낀다. 잘되겠지 싶은 것도 반드시 사용자 환경에서 다시 한번 테스트 해봐야 겠다.","pubDate":"Mon, 28 Nov 2016 15:00:00 GMT","guid":"https://CSS-Org.github.io/2016/11/29/when-using-localstorage-within-the-ie/","category":"Tech"},{"title":"ES6 Class에서 private member를 정의하는 방법","link":"https://CSS-Org.github.io/2016/11/27/how-to-make-private-member/","description":"es6의 class 문법에는 private data를 직접 지정할 수 있는 기능이 제공되지 않는다.때문에 private data로 쓰고자 하는 변수는 우회적으로 관리하여야 하는데, 그 방법들을 소개한다.","pubDate":"Sun, 27 Nov 2016 08:34:00 GMT","guid":"https://CSS-Org.github.io/2016/11/27/how-to-make-private-member/","category":"es6,javascript,class"},{"title":"동시성 환경에서 SimpleDateFormat 사용시 주의가 필요하다.","link":"https://CSS-Org.github.io/2016/11/16/dangerous-simpledateformat/","description":"개요웹은 기본적으로 동시성을 기반으로 하지만 의외로 우리 개발자들은 동시성에 취약한 코드를 작성하곤 한다.책에도 종종 소개되고 본인도 경험해본, 심지어 최근 회사 레거시 프로젝트 코드에서도 발견한 SimpleDateFormat 이슈를 간단히 소개해 본다. 다음 코드는 thread-safe 할까?출처 : ‘7가지 동시성 모델’1234567class DateParser &#123; private final DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); public Date parse(String s) throws ParseException &#123; return format.parse(s); &#125;&#125; 숨겨진 가변 상태의 위험성언뜻 보기엔 유일한 멤버변수인 format이 final로 선언되어 있어 변경 불가능한 클래스로 보인다.하지만 SimpleDateFormat 내부에서는 가변 상태를 가지고 있기 때문에 결국 DateParser 클래스는 thread-safe 하지 않다.이 때 NumberFormatException 같은 명시적인 오류가 발생하면 차라리 버그를 인지하기 쉽다. 하지만 올바르지 못한 값을 반환하면서 오류가 발생하지 않는 경우 버그를 인지하는데 상당한 시간이 걸릴 수 있다. 그럼 어떻게 해야하나?사실 SimpleDateFormat 객체를 필요할 때 마다 새로 생성해서 쓰면 쉽게 해결이 가능하다.하지만 유틸성 작업에 매번 객체 생성이라니 뭔가 나이스하지 않다.그렇다. 세상엔 이미 잘 만들어진 바퀴들이 존재한다. thread-safe하면서 빠르기까지한 아래 클래스들을 대신 사용하자. Apache Commons 라이브러리 내 FastDateFormat 클래스. Joda Time 라이브러리 내 DateTimeFormatter 클래스(java8에서는 기본 내장). 결론불변성에 대한 언어적 지원(제약)이 약한 자바 언어로 웹 프로그래밍을 할 때는 이러한 동시성 이슈를 항시 고민하는 습관이 필요하다. 특히 위 경우처럼 외부 라이브러리를 가져다 멤버 변수로 사용할 때는 thread-safe 한지 반드시 확인후 사용해야 한다.","pubDate":"Wed, 16 Nov 2016 02:22:37 GMT","guid":"https://CSS-Org.github.io/2016/11/16/dangerous-simpledateformat/","category":"java,concurrency"},{"title":"PKI - Public Key Interface","link":"https://CSS-Org.github.io/2016/11/15/pki/","description":"PKI - Public Key Interface 암호화는 코드 및 암호를 통해 정보를 보호하는 기술이다. 코드는 정보 변경 방법을 모르는 상태로 읽을 수 없도록 하기 위해 정보를 체계적으로 변경하는 프로세스이다. 정보를 코드로 변경하는 작업을 “암호화”, 코드를 정보로 되돌리는걸 “해독” 이라고 한다. 암호화를 할때 사용된 수단 혹은 정보를 키라고 하며 이때 사용된 방식을 암호화 알고리즘이라고 한다. 정리하면 암호화 : 정보를 코드로 변환 해독 : 코드를 정보로 변환 키 : 정보를 코드로 변환할 때 사용된 정보 암호화 알고리즘 : 정보를 코드로 변경할 때 사용된 방식 예를 들어… A는 “Hello World” 라는 정보를 B에게 전송한다.이때 A는 암호화 키로서 l이라는 알파벳을 모두 A로 바꾸는 키를 사용하였고 이걸 심플 알고리즘이라고 이름붙였다.B는 코드로서 “HeAAo WorAd” 라는 코드를 받았다. 애초에 서로 가진 키와 알고리즘을 통해 이 코드는 A를 l로 바꾼 것임을 알고, 암호 해독을 실행하여 “Hello World” 라는 정보를 얻어냈다. 이러한 암호화 방식을 대칭 키 암호화라고 한다.A와 B가 동일한 키를 가지고 있기 때문이다. 심플하지만 이것이 앞으로 나올 암호화의 기본이 된다. 좀더 발전된 형태의 암호화가 선보였는데, 1976년에 Whitfield Diffe 와 Martin Hellman 에 의해 공개 키 암호화가 발표되었다.이 암호화는 두개의 키를 사용한다. 하나는 개인키(비밀키)로서 오로지 자신만 소유한다. 하나는 공개키(공유키)로서 외부에 공개해 둔다. 두개의 키는 수학 알고리즘으로 묶여 있다. 이제 다시 예를 들자. A는 B에게 메시지를 보내기 위해 B에게 공개키를 요구한다. B는 A에게 자신이 가진 개인키와 쌍을 이루고 있는 공개 키를 공개하고, A는 그 키를 받아 B에게 보낼 정보를 암호화하여 코드로 만든다. B는 코드를 받으면 자신의 개인 키로 해독, A가 보내려 했던 정보를 볼 수 있다 이 암호화 방식으로 얻어지는 이점은 정보의 교환 말고 여러가지가 있다. 그중 대표적인 건 디지털 서명 이라는 송신자를 확인할 수 있는 이점이다. 개인키는 오로지 하나의 소유자만이 소유할 수 있기에 만일 개인키로 암호화한 코드는 그 개인이 암호화했다는걸 증명하는 서명과 같이 동작한다. 디지털 서명의 방법의 플로우는 정보를 자신의 개인키로 암호화하여 암호화문과 별도로 메시지 헤더등에 추가한다. 이걸 서명이라고 한다. 그리고 보낼 사람의 공개키로도 정보를 암호화한다. 받는 측은 메시지 송신자의 진위여부를 파악하기 위해 송신자의 공개키로 헤더의 서명 암호화를 해독한다. 그리고 정보또한 자신의 개인키로 해독한다. 두 내용이 일치하면 송신자가 조작되지 않았음을 알 수 있다. 여기서…정보 외에 헤더에 추가하는 서명은 부하등의 이유로 먼저 본문을 약속된 해시 알고리즘으로 해쉬한뒤 서명을 생성하는게 보통이다. 여기서 주의할 점이 있다. 일반적인 공개키 암호화 방식은 복잡한 수학 연산에 의해 부하가 상당하다.이 부하를 피하기 위해서 대칭키 암호화와 섞어 사용하는게 보통이다. 그렇다. 공개키 암호화 방식으로 대칭키 자체를 암호화해 보내는 방법이다. 키 자체만을 암호화하기 때문에 부하가 상대적으로 비용이 적다. 여기까지 설명한 방법을 모두 합친 암호화 및 서명 플로우는 다음과 같다. 정보를 해시한뒤 그 값을 자신의 개인키로 암호화한다. 그 결과를 보낼 메시지에 추가한다. 이것을 서명이라고 한다. 일회용의 대칭키를 생성한다. 대칭키로 정보를 암호화하여 보낼 메시지에 추가한다. 받는 사람의 공개키를 획득한다. 받는 사람의 공개키로 일회용의 대칭 키를 암호화한다. 그 결과를 보낼 메시지에 추가한다. 수신자는 메시지에서 서명, 암호화된 일회용 대칭키, 암호화된 코드를 확인하고 분리한다. 수신자의 개인키로 암호화된 일회용 대칭키를 해독한다. 해독된 대칭 키로 코드를 해독한다. 보낸 사람의 공개키를 획득한다. 서명을 보낸 사람의 공개키로 해독하고 그 결과를 위에서 해독된 코드의 정보를 해시하여 비교한다. 값이 일치하면 메시지와 송신자가 유효한 것이 증명된다.","pubDate":"Mon, 14 Nov 2016 15:00:00 GMT","guid":"https://CSS-Org.github.io/2016/11/15/pki/","category":"Tech,Security,Async"},{"title":"JavaScript Module Injector 만들기","link":"https://CSS-Org.github.io/2016/11/04/javascriptor-module-injector/","description":"과거 개인 블로그 글을 가져온 포스트입니다 JavaScript에서 DI를…최근 AngularJS 에 관심이 많아서 여러모로 살펴보는 중인데, 그 중에서도 재미있게 본 것은 Dependecy Injection 을 JavaScript 레벨에서 지원해준다는 것이었다. Java 등에서 쓰이는 Spring Framework에서는 ApplicationContext 에 빈을 등록해두면 특정 애노테이션을 확인하여 DI 해주는 방식으로 진행되지만 JavaScript에서는 Annotation 같은 것이 없고 (비슷하게 구현해볼 수는 있지만 낭비…) 다른 방법으로 구현해야 한다. 비결은 Function.prototype.toString 에 있었다. Function.toStringJavaScript의 함수는 toString을 할 경우 함수의 소스코드를 문자열로 반환한다. 12345function imFunction(you, say, ho) &#123; console.log(you, say, ho);&#125;document.getElementById('result').innerHTML = imFunction.toString(); jsFiddle 여기서 중요한 것은 함수의 인자 목록도 문자열에 포함되어 있다는 것이다. 이걸 활용하면, DI를 흉내내볼 수 있다. 구현시작…먼저 정규식이 필요하다 함수의 toString 결과를 함수의 이름, 인자, 몸체.이 셋으로 나눠볼 정규식을 만들어보자. (함수 몸체와 이름은 일단 쓸일이 없지만 후 확장을 위해 한번에 구해봤다..) 1var FN_PARSE = /^function\\s*(\\S+)[^\\(]*\\(\\s*([^\\)]*)\\)\\s*\\&#123;([\\W\\w]+)\\&#125;$/m 위 정규식으로 match 할 경우 [toString 결과, 함수 이름, 함수 인자, 함수 몸체] 의 배열을 얻을 수 있다. 주의할 점이, 자바스크립트는 함수 인자 목록에도 주석을 사용할 수 있기에 자칫 주석으로 인자 이름을 잘못 가져올 수 있다. 주석을 제거하는 정규표현식도 준비한다. 1var STRIP_COMMENT = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg 그렇다면 적당한 함수를 하나 준비해본다 123function hello(man, to, women) &#123; console.log(man + to + women);&#125; 파싱해보자. 1234567891011var FN_PARSE = /^function\\s*(\\S+)[^\\(]*\\(\\s*([^\\)]*)\\)\\s*\\&#123;([\\W\\w]+)\\&#125;$/m, STRIP_COMMENT = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;function hello(man, to, women) &#123; console.log(man + to + women);&#125;var parsed = hello.toString().match(FN_PARSE), fnName = parsed[1], fnArgs = parsed[2].replace(STRIP_COMMENT, '').split(',') fnBody = parsed[3]; 잘 된다! jsFiddle 모듈 레지스트리 및 인젝터 구현그럼 남은일은 모듈을 등록할 레지스트리를 구현하는 일이다. 여기서는 간단히 이름 기반의 DI만 지원하는 것으로 하고, 키-값 객체로 관리하게 해보자. 일단 AMD 모듈이 아닌 일반적인 모듈로 구현해봤다. 1234567891011121314151617181920212223242526272829303132333435363738394041(function(ctx) &#123; var FN_PARSE = /^function\\s*(\\S+)[^\\(]*\\(\\s*([^\\)]*)\\)\\s*\\&#123;([\\W\\w]+)\\&#125;$/m, STRIP_COMMENT = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg, M = &#123;&#125;; ctx.Injector = &#123; // 의존성 모듈을 새로 등록한다. register: function(name, mo) &#123; M[name] = mo; &#125;, // 함수를 받아 의존성을 주입한 뒤 즉시 실행한다. execute: function(fn, ctx) &#123; return this.di(fn, ctx || this)(); &#125;, // 함수를 받아 의존성을 주입한다. di: function(fn, ctx)&#123; // 함수를 정규식으로 분해한다. var parsed = fn.toString().match(FN_PARSE), fnName = parsed[1], args = parsed[2].replace(STRIP_COMMENT, '').split(','), body = parsed[3], i = 0, j, injected = []; // 인자의 이름으로 레지스트리에서 찾아 순서대로 적재 for(j = args.length; i &lt; j; i++) &#123; injected[i] = M[args[i].trim()] || undefined; &#125; // 래핑 함수를 반환한다. return function() &#123; return fn.apply(ctx || null, injected); &#125; &#125; &#125;;&#125;)(this); di 함수에서 대해 조금 설명하면, 함수를 먼저 분석기로 쪼개서 배열을 얻은 뒤, 인자 배열을 돌면서 등록된 모듈과 매치하는 배열을 생성한 뒤 wrap 하여 반환하는 방식이다. 어디 잘 돌아가나 테스트. 123456789101112131415161718192021222324252627var Coffee = &#123; pour: function(some) &#123; return \"커피를 \" + some + \"에 따르고 \"; &#125;&#125;var Milk = &#123; pour: function(some) &#123; return \"우유를 \" + some + \"에 따르고 \" &#125;&#125;Injector.register('coffee', Coffee);Injector.register('milk', Milk);function Cup(coffee, milk) &#123; var me = \"머그컵\"; return coffee.pour(me) + milk.pour(me) + \" 섞어 마신다\";&#125;var drink = Injector.di(Cup);var coffeeMilk = drink(), directDrink = Injector.execute(Cup);console.log(coffeeMilk); // 커피를 머그컵에 따르고 우유를 머그컵에 따르고 섞어 마신다console.log(coffeeMilk == directDrink); // true 맛있는 커피우유가 만들어진 것 같다. jsFiddle 생각해볼 것들.현재 구현이 포스팅하며 날림한거라 미비하거나 주의할 점이 몇가지 있다 uglify 등 minify 할 경우 인자 이름이 보존이 안된다. mangle 옵션 등으로 인자이름을 보전해야 올바른 동작이 가능하다. 래핑 함수를 반환하는 관계로 스코프가 꼬일 수 있다.","pubDate":"Fri, 04 Nov 2016 08:00:00 GMT","guid":"https://CSS-Org.github.io/2016/11/04/javascriptor-module-injector/","category":"javascript,di,module"},{"title":"비개발자도 따라해보는 Hexo 로 페이지 만들기","link":"https://CSS-Org.github.io/2016/11/01/hexo-everyone-no-developer/","description":"시작해보기Hexo 란 무엇인가정적 사이트 생성기이다 정적 사이트 생성기란 무엇인가웹페이지에 필요한 HTML 문서, 스타일시트, JavaScript 등을 자동으로 생성해주는 것이다 HTML? 이게 뭔가우리가 인터넷 익스플로러나 크롬, 혹은 모바일 브라우저로 보는 페이지는 사실 단순한 규칙에 따른 문자열이다. 예전 컴퓨터가 발달하기 전에는 소설이나 기사를 작성하여 출판사에 넘길 때, 원고지에 직접 손으로 썼었다. 한글이나 MS 워드가 아니기에 글자 굵기라든가, 띄어쓰기, 줄 바꿈 및 이미지 삽입 등을 간단한 기호로 표시하여 출판작업에 참고하도록 했는데, 이것에는 일정한 규칙이 있었다. 가령 이런 식이다. 1234567891011121314&lt;굵게&gt;&lt;크게&gt;소나기-황순원&lt;/크게&gt;&lt;/굵게&gt;그러다가 소녀가 물 속에서 무엇을 하나 집어낸다. 하얀 조약돌이었다.&lt;줄바꿈 /&gt;그리고는 벌떡 일어나 팔짝팔짝 징검다리를 뛰어 건너간다.&lt;줄바꿈 /&gt;&lt;줄바꿈 /&gt;다 건너가더니만 홱 이리로 돌아서며,&lt;줄바꿈 /&gt;&lt;인용&gt;&quot;이 바보.&quot;&lt;/인용&gt;&lt;줄바꿈 /&gt;조약돌이 날아왔다.&lt;줄바꿈 /&gt;소년은 저도 모르게 벌떡 일어섰다. 이 원고로 쓰였다면 실제 출판물은 소나기-황순원그러다가 소녀가 물 속에서 무엇을 하나 집어낸다. 하얀 조약돌이었다.그리고는 벌떡 일어나 팔짝팔짝 징검다리를 뛰어 건너간다.다 건너가더니만 홱 이리로 돌아서며,“이 바보.”조약돌이 날아왔다.소년은 저도 모르게 벌떡 일어섰다. 같이 나오는 것이다. 저런 서식이 정규화되어 여러 살을 붙여 발전해온 것이 HTML 이다 JavaScript? 스타일시트?최근의 웹 페이지는 예전처럼 정적인 컨텐츠만 표현하지 않고 사용자의 입력에 반응한다. 그리고 글자의 폰트도 다양하게 표현된다. 이런 규칙이나 리액션을 구현할 수 있게 해주는 일종의 규칙 언어이다. 잘 모르겠다. 이런거 다 알아야 페이지나 블로그 만들 수 있나?아니다. 처음 세팅만 잘 하면 몰라도 된다. 다만 마크다운 문법은 조금 알고 있어야 한다 마크다운?문서 작성을 위한 간결한 문법이다. 아, 걱정할 것 없다. 매우 쉽다. 정말이다. 그래, Hexo 가 HTML, JavaScript, 스타일시트를 만들어주는건 알겠다. 그럼 서버에 올리는건 어떻게 하나Hexo가 아주 쉽게 해 준다. 간단한 명령어 하나로 끝난다. 정말이다. 명령어 하나 치고 커피한잔 하면 내 휴대폰에서 내가 올린 글을 볼 수 있다. 이제 바로 시작해 보자 Github 가입하기 Hexo 로 정적 사이트를 생성해도 이것을 서비스해줄 서버가 없다면 무용지물이다. Github 에서는 Github Page 라는 정적 리소스 제공 서버를 제공한다. 여기에 생성된 파일을 올리면 페이지를 서비스할 수 있다. 일단은 회원 가입부터 하자. 회원가입 링크 가입 폼 아이디가 도메인 주소가 되므로 신중하게 결정하는게 좋다. 가령 superman 이 아이디라면 superman.github.io 가 도메인 이름이 된다. 다음엔 서비스 선택인데, 무료로도 충분하며, 저장소의 카테고리까지 정하고 나면 완료. 이제 페이지 서비스를 올릴 저장소를 생성해야 한다. 중요한건 저장소 이름을 만들 때 가급적 아이디.github.io 의 형식으로 만드는게 귀찮은 일이 줄어든다. 여기까지 했다면 50%는 완료한 것이다. 환경 설정하기두개를 설치해야 한다. nodejs git NodeJS 설치Git 설치본격적으로 시작하기 작성중 …. to be continued..","pubDate":"Tue, 01 Nov 2016 13:10:13 GMT","guid":"https://CSS-Org.github.io/2016/11/01/hexo-everyone-no-developer/","category":"no-developer,blog,newbee"},{"title":"ReactJS를 작성할 때에 알아두면 좋은 ES6 문법들","link":"https://CSS-Org.github.io/2016/10/28/es6-for-reactjs/","description":"ReactJS를 작성할 때에 알아두면 좋은 ES6 문법들block scope기존의 함수에 의한 스코프처럼 { }으로 감싼 내부에 별도의 스코프가 생성된다. 123456789&#123; let a = 10; &#123; let a = 20; console.log(a); // (1) &#125; console.log(a); // (2)&#125;console.log(a); // (3) 123456let sum = 0;for(let j = 1 ; j &lt;= 10 ; j++)&#123; sum += j;&#125;console.log(sum); // (1)console.log(j); // (2) 12345678if(Math.random() &lt; 0.5) &#123; let j = 0; console.log(j); // (1)&#125; else &#123; let j = 1; console.log(j); // (2)&#125;console.log(j); // (3) block scoped variableslet은 기존의 var를 대체하는 블락변수이고, const는 그 중 한 번 선언 및 정의되고 나면 값을 변경할 수 없는 변수이다.블락 스코프 내부에서 선언된 let, const는 해당 스코프 내에서만 존재하며, 이들에 대해서는 ‘TDZ’가 존재한다. TDZ (temporal dead zone, 임시사각지대) : 블락 스코프 내에서는 지역변수/상수에 대한 호이스팅이 이뤄지기는 하나, 선언된 위치 이전까지는 해당 변수/상수를 인식하지 못한다. 123console.log(a); // (1)let a = 2;console.log(a); // (2) 12345var a = 10;let b = 20;console.log(a, b); // (1)console.log(window.a, window.b); // (2)console.log(this.a, this.b); // (3) 1234for(let j = 0; j &lt; 5; j++)&#123; console.log(j);&#125;console.log(j); // (1) 12const PI = 3.141593;PI = 3.14; // (1) 1234567891011121314const OBJ = &#123; prop1 : 1, prop2 : [2, 3, 4], prop3 : &#123;a: 1, b: 2&#125;&#125;;Object.freeze(OBJ);OBJ.prop1 = 3;OBJ.prop2.push(5);OBJ.prop3.b = 3;console.log(OBJ); // (1)Object.freeze(OBJ.prop2);OBJ.prop2.push(6);console.log(OBJ); // (2) 링크 : Object.freeze 및 deep freezing 변수별 스코프 종속성 variables \\ scope function block hoisting TDZ let O O O O const O O O O var O X O X function declaration O △ O X 함수선언문의 경우 sloppy-mode 모드에서는 block-scope의 영향을 받지 않고, strict-mode에서는 block-scope의 영향을 받는다. 123456789&#123; foo(); function foo()&#123; console.log(1); &#125; &#123; foo(); function foo()&#123; console.log(2);&#125; &#125;&#125;foo(); 12345678910'use strict';&#123; foo(); function foo()&#123; console.log(1); &#125; &#123; foo(); function foo()&#123; console.log(2);&#125; &#125;&#125;foo(); arrow function순수 함수로서의 기능만을 담당하기 위해 간소화한 함수.=&gt;의 좌측엔 매개변수, 우측엔 return될 내용을 기입한다. 우측이 여러줄로 이루어져있다면 { }로 묶을 수 있으며, 이 경우엔 명시적으로 return을 기술하지 않으면 undefined가 반환된다. 12345678910111213141516let getDate = () =&gt; new Date();let sum = (a, b) =&gt; a + b;let getSquare = a =&gt; &#123; return a * a; &#125;let calc = (method, a, b) =&gt; &#123; switch(method) &#123; case 'sum': return a + b; case 'sub': return a - b; case 'mul': return a * b; case 'div': return a / b; &#125; return null;&#125;console.log(getDate());console.log(sum(4, 5));console.log(getSquare(10));console.log(calc('mul', 3, 4)); 1234567891011const obj = &#123; grades: [80, 90, 100], getTotal: function() &#123; this.total = 0; this.grades.forEach(v =&gt; &#123; this.total += v; &#125;); &#125;&#125;;obj.getTotal();console.log(obj.total); // (1) rest parameter 함수 파라미터에 일정하지 않은 값들을 넘기고자 할 경우에 유용. arguments의 대체. 배열의 얕은복사 목적으로 활용 가능. 1234function f(x, y, ...rest) &#123; console.log(rest); // (1)&#125;f(1, 2, true, null, undefined, 10); 12345678910const sum = function(...arg) &#123; let result = 0; for(let i = 0; i &lt; arg.length ; i++)&#123; result += arg[i]; &#125; return result;&#125;;/* const sum = (...arg) =&gt; arg.reduce((p,c)=&gt; p+c); */console.log(sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)); // (1) spread operator문자열의 각 단어, 배열의 요소들이나 객체의 프로퍼티들(stage-2 proposal)을 해체하여 여러개의 값으로 반환해준다. 1234const str = 'lorem ipsum';const arr = [20, 10, 30, 40, 50];console.log(...arr); // (1)console.log([...str]); // (2) 123456const originalArray = [1, 2];const copiedArray = [...originalArray];originalArray.push(3);console.log(originalArray); // (1)console.log(copiedArray); // (2) default parameter파라미터에 값을 할당하지 않거나 빈 값인 상태로 함수를 호출할 경우, 해당 파라미터를 지정한 기본값으로 인식하도록 해줌.각 파라미터는 내부에서 let과 동일하게 동작하며, 따라서 TDZ가 존재한다. 1234function f(x = 1, y = 2, z = 3)&#123; console.log(x, y, z); //(1)&#125;f(4, undefined, 5); 12345function multiply(x = y * 3, y)&#123; console.log(x * y);&#125;multiply(2, 3); // (1)multiply(undefined, 2); // (2) Enhanced Object Literalcomputed property key프로퍼티의 키값에 표현식을 지정할 수 있다. 123456const suffix = ' name';const iu = &#123; ['last' + suffix] : '이', ['first' + suffix] : '지은'&#125;;console.log(iu); // (1) 123456789101112const foo = (() =&gt; &#123; let count = 0; return function()&#123; return count++; &#125;;&#125;)();const obj = &#123; ['bar' + foo()] : foo(), ['bar' + foo()] : foo()&#125;;console.log(obj); // (1) property Shorthand프로퍼티의 키와 값에 할당한 변수명이 동일한 경우, 키를 생략할 수 있다. 123456const x = 10, y = 20;const obj = &#123; x, y&#125;;console.log(obj); // (1) 123456789function setInformation(name, age, gender)&#123; return &#123; name, age, gender &#125;;&#125;const iu = setInformation('아이유', 23, 'female');console.log(iu); // (1) method Shorthand메서드명 뒤의 : function 키워드를 생략할 수 있게 되었다. 1234567891011const obj = &#123; name : 'foo', getName() &#123; return this.name; &#125;, printName(name) &#123; console.log(this.getName()); &#125;&#125;;console.log(obj.getName()); // (1)obj.printName(); // (2) Object.assign (ES5)Object.assign()객체의 얕은복사를 수행한다. 12345678910const originalObj = &#123; a: 1, b: [2, 3, 4], c: &#123; d: 5, e: 6 &#125;&#125;;const copiedObj = Object.assign(&#123;&#125;, originalObj);copiedObj.a = 11;copiedObj.b[0] = 12;copiedObj.c.d = 13;console.log(originalObj, copiedObj); // (1) 123456const originalObj = &#123; a: [2, 3, 4], b: &#123; d: 5, e: 6 &#125;&#125;;const copiedObj = Object.assign(&#123;&#125;, originalObj, &#123; b: &#123; f: 7, g: 8 &#125; &#125;);console.log(copiedObj); // (1) template literals여러줄 문자열, 보간(표현식 삽입) 등을 지원하는 새로운 형태의 문자열. 123console.log(`abbccc`); // (1) 1234const a = 10;const b = 20;const str = `$&#123;a&#125; + $&#123;b&#125; = $&#123; a + b &#125;`;console.log(str); // (1) 12345678910111213141516171819202122const characters = [&#123; name: 'Aria Stark', lines: ['A girl has no name.']&#125;, &#123; name: 'John Snow', lines: [ 'You know nothing, John Snow.', 'Winter is coming.' ]&#125;];const html = characters.reduce((prevCharacters, currentCaracter) =&gt; &#123; const &#123; name, lines &#125; = currentCaracter; return `$&#123;prevCharacters&#125;&lt;article&gt; &lt;h1&gt;$&#123;name&#125;&lt;/h1&gt; &lt;ul&gt;$&#123;lines.reduce((prevLines, currentLine) =&gt; `$&#123;prevLines || ''&#125; &lt;li&gt;$&#123;currentLine&#125;&lt;/li&gt;` , '')&#125; &lt;/ul&gt;&lt;/article&gt;`&#125;, '');console.log(html); // (1) classJava의 그것과 비슷하지만 private 메서드가 없다. 12345678910111213141516171819202122232425262728293031323334class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; &#125; toString() &#123; return `$&#123;this.name&#125;, $&#123;this.age&#125;세`; &#125; static logNames(persons) &#123; for (const person of persons) &#123; console.log(person.name, person.age); &#125; &#125;&#125;class Employee extends Person &#123; static logNames(persons) &#123; for (const person of persons) &#123; console.log(person.name, person.age, person.title); &#125; &#125; constructor(name, age, title) &#123; super(name, age); this.title = title; &#125; toString() &#123; return `$&#123;super.toString()&#125;, ($&#123;this.title&#125;)`; &#125;&#125;const park = new Employee('Park', 35, 'CTO');const jung = new Employee('Jung', 30, 'CEO');console.log(park.toString()); // (1)Person.logNames([park, jung]); // (2)Employee.logNames([park, jung]); // (3) module - import / exportwithout ‘default’ export1234567891011121314151617//------ lib.js ------export const sqrt = Math.sqrt;export function square(x) &#123; return x * x;&#125;//------ main.js ------import * as lib from './lib';console.log(lib); // (1)console.log(lib.square(5)); // (2)console.log(lib.sqrt(4)); // (3)/* or */import &#123; square, sqrt &#125; from './lib';console.log(square(5)); // (4)console.log(sqrt(4)); // (5) with ‘default’ export123456789101112131415161718192021//------ lib.js ------export default function lib() &#123; console.log('this is lib default function');&#125;export const sqrt = Math.sqrt;export function square(x) &#123; return x * x;&#125;//------ main.js ------import * as lib from './lib';console.log(lib.default()); // (1)console.log(lib.square(5)); // (2)console.log(lib.sqrt(4)); // (3)/* or */import lib, &#123; square, sqrt &#125; from 'lib';console.log(lib); // (4)console.log(square(5)); // (5)console.log(sqrt(4)); // (6)","pubDate":"Fri, 28 Oct 2016 14:33:25 GMT","guid":"https://CSS-Org.github.io/2016/10/28/es6-for-reactjs/","category":"javascript, es6"},{"title":"JS 숫자 변환 이모저모","link":"https://CSS-Org.github.io/2016/10/28/js-convert-number/","description":"js 의 숫자 변환자바스크립트 숫자 변환은 parseInt, parseFloat, Number 등이 있다. parseInt 와 parseFloat 는 이름 그대로의 기능을 한다 123var num = \"32.4\"parseInt(num); // 32parseFloat(num); // 32.4 Number 도 일견 parseFloat 와 비슷하다. 히지만 세부 동작은 조금씩 다르다. 자세한건 아래에서 계속 이야기해보자. 123var num = \"32.4\"Number(num); // 32Number(num); // 32.4 parseIntparseInt 는 첫번째 인자가 숫자가 아니면 ECMAScript 표준의 ToString 연산 을 수행한다. (영문 및 장문 주의)그 다음에 ToString 결과로 반환된 값으로 숫자 변환을 시작한다. 여기서 parseInt 와 parseFloat 가 약간 다른데, parseInt 는 추가적인 두번째 인자로 radix 를 지정해줄 수 있다. 다음 예제를 보자 12345var num = \"1010\";parseInt(num, 2); // 10var num = \"FF\";parseInt(num, 16); // 255 명세에서는 radix 를 주지 않을 경우 10진수 해석을 명시하고 있지만, 구형 브라우저나 (가령 IE7 이하) 구현에 따라 바뀔 수 있으므로, parseInt 사용시에는 두번째 인자에 반드시 radix 를 주는게 좋다. radix가 없는 8진 해석 또한 인자 첫번째의 공백이나 첫번째가 아닌 자릿수에 문자열이 섞일 경우 무시하며 0x 나 0X 로 시작하는 문자열은 radix 를 16으로 가정한다. 123parseInt(\"1A\", 10); // 1parseInt(\" 3 2\", 10); // 3parseInt(\"0xFF\"); // 255 parseFloat문자열 인수를 인자로 받아 부동 소수점 수를 반환한다. 인자가 문자열이 아니면 ToString) 연산을 수행한다. parseFloat 는 주어진 인자를 parseInt 와는 다르게 변환 대상이 될 인자 하나만 받는다. 이 함수 역시 parseInt 와 같게 ToString 을 수행 후 변환을 시도한다. 변환 실패 시 NaN 을 반환하는 것도 같다. 1parseFloat(\"1.23\") // 1.23; Infinity 를 해석할 수 없어 NaN 을 반환하는 parseInt 와 다르게 parseFloat 는 NaN 을 반환하지 않는다 12parseInt(Infinity) // NaNparseFloat(Infinity) // Infinity NumberNumber 는 통상 parseFloat 와 비슷하다고 생각할 수 있다. 하지만 세부적으로 약간 다른데, ToNumber 라는 작업으로 진행된다. (영어 및 표준문서 압박 주의) 정수형 변환일 불가능한 문자열이 있을 경우 NaN 이 반환된다 12parseFloat(\"1a\") // 1Number(\"1a\") // NaN 16진수 형식의 문자열일 경우 parseFloat 와는 다르게 해석이 가능하다 12parseFloat(\"0x10\") // 0Number(\"0x10\") // 16 어떤 코드를 보다보면 값에 + 연산자를 붙여 처리하는 표현식을 본 일이 있을것이다. (없다고??) 이 표현은 Number(val) 과 거의 동일하다고 보면 정확하다 123+\"2\" === Number(\"2\") // true+[] === Number([]) // true+new Date === Number(new Date()) // true bitwise비트연산이 왜 나오는지 뜬금없어 할 수도 있다. 하지만 비트 연산으로도 숫자 변환이 가능하다. 그리고 명세상 성능이 타 변환보다 빠를 수 있다. (물론 구현에 따라 다를 수 있다.) 12345678910// 777.77 을 정수형으로 변환 시도// 결과는 전부 10진 정수 [777]parseInt(777.77, 10)Math.floor(777.77)~~777.77777.77 | 0777.77 &gt;&gt; 0777.77 &gt;&gt;&gt; 0777.77 &lt;&lt; 0 비트연산 시 명세에서는 피연산자를 ToUint32 작업을 선행하여 강제 변환하게 되어 있기에 이런게 가능하다. 이런 문법은 일종의 언어 스펙을 이용한 트릭이라고 할 수 있다. 이것에 대해서 잘 알지 못하면 알수없는 암호문이 되어 버리니 팀원과의 소통은 필수다. 비트연산을 썼을때의 장점은 일반적으로 타 방법 (parseXXX, Number) 보다 빠르다 뭔가 뛰어난 프로그래머가 된 느낌을 받을 수 있다. 주의할 점은 Uint32 형이기에 원래의 값에 변형이 올 수 있으니 주의해야 한다. (음수라거나 int 형을 초과하는 경우) 참고: 각 연산법에 대한 성능비교Number() vs parseInt() vs plus vs bitwise","pubDate":"Fri, 28 Oct 2016 02:25:41 GMT","guid":"https://CSS-Org.github.io/2016/10/28/js-convert-number/","category":"javascript,parseInt,bitwise"},{"title":"블로그 글 쓰기","link":"https://CSS-Org.github.io/2016/10/01/getting-started/","description":"Installation12345$ git clone https://github.com/CSS-Org/CSS-Org.github.io.git$ cd CSS-Org.github.io$ git checkout -b working origin/working$ npm i$ npm run server Deploy1$ npm run deploy Documentationhttps://hexo.io/ko/ Configuration{root}/_config.yml 파일을 열어 다음 프로퍼티를 수정한다. 123# @file &#123;root&#125;/_config.ymltheme: [&#123;root&#125;/themes/테마디렉토리 에서 테마디렉토리명] yml 파일이란?위키백과:YAML. 일단은 ‘사람이 쉽게 읽을 수 있는’ 데이터 직렬화 양식 이라고 한다…JSON 과 유사하지만 bracket 대신 줄바꿈과 들여쓰기로 표현한다고 보면 얼추 정확하다. 가령 theme/clean-blog 테마를 적용한다면 123# @file &#123;root&#125;/_config.ymltheme: clean-blog 가 된다. 현재 다운로드 되어 있는 테마는 다음과 같다. clean-blog 의 경우 약간 커스터마이징을 해서 clean-blog-custom 으로 리네임해둔 상태다. clean-blog 미리보기 hueman 미리보기 더 많은 테마는 다음 링크에 있다.https://hexo.io/themes/ Writing1$ hexo new [제목] 실행 후에는 {root}/source/_post/ 아래에 글제목.md 파일이 생성된다. 문법은 마크다운 문법이고, wiki 등에서 쓰는 문법과 비슷하다.","pubDate":"Sat, 01 Oct 2016 02:25:41 GMT","guid":"https://CSS-Org.github.io/2016/10/01/getting-started/","category":"document,start,writing,manual"}]}